<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="auroraoo577">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="auroraoo577">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="1.Linux基本命令Bash解析器常用快捷键遍历输入的历史命令 从当前位置向上遍历：ctrl + p （↑） 从当前位置向下遍历： ctrl + n（↓）  光标相关操作 光标左移： ctrl + b（back） （←） 坐标右移： ctrl + f（front） （→） 移动到头部： ctrl + a（ahead） 移动到尾部： ctlr + e（End）  字符删除 删除光标前边的字符：ct">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://auroraoo577.github.io.git/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="New Blog">
<meta property="og:description" content="1.Linux基本命令Bash解析器常用快捷键遍历输入的历史命令 从当前位置向上遍历：ctrl + p （↑） 从当前位置向下遍历： ctrl + n（↓）  光标相关操作 光标左移： ctrl + b（back） （←） 坐标右移： ctrl + f（front） （→） 移动到头部： ctrl + a（ahead） 移动到尾部： ctlr + e（End）  字符删除 删除光标前边的字符：ct">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.2it4biftu9a0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.4pcberglbfk0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.6suwowfml400.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.4k490wpc1je0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.6gsojomqb000.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.3pvfoqk16yu0.webp">
<meta property="article:published_time" content="2023-05-24T13:05:47.560Z">
<meta property="article:modified_time" content="2023-06-10T09:50:06.700Z">
<meta property="article:author" content="auroraoo577">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.2it4biftu9a0.webp">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>操作系统 · auroraoo&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon1.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 6.3.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >auroraoo&#39;s Studio.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">操作系统</a>
            </div>
    </div>
    
    <a class="home-link" href=/>auroraoo's Studio.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg1.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            操作系统
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">8.7k</span>Reading time: <span class="post-count reading-time">34 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2023/05/24</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="1-Linux基本命令"><a href="#1-Linux基本命令" class="headerlink" title="1.Linux基本命令"></a>1.Linux基本命令</h2><h3 id="Bash解析器常用快捷键"><a href="#Bash解析器常用快捷键" class="headerlink" title="Bash解析器常用快捷键"></a>Bash解析器常用快捷键</h3><h4 id="遍历输入的历史命令"><a href="#遍历输入的历史命令" class="headerlink" title="遍历输入的历史命令"></a><strong>遍历输入的历史命令</strong></h4><ul>
<li>从当前位置向上遍历：ctrl + p （<strong>↑</strong>）</li>
<li>从当前位置向下遍历： ctrl + n（<strong>↓</strong>）</li>
</ul>
<h4 id="光标相关操作"><a href="#光标相关操作" class="headerlink" title="光标相关操作"></a><strong>光标相关操作</strong></h4><ul>
<li>光标左移： ctrl + b（<strong>back</strong>） （<strong>←</strong>）</li>
<li>坐标右移： ctrl + f（<strong>front</strong>） （<strong>→</strong>）</li>
<li>移动到头部： ctrl + a（<strong>ahead</strong>）</li>
<li>移动到尾部： ctlr + e（<strong>End</strong>）</li>
</ul>
<h4 id="字符删除"><a href="#字符删除" class="headerlink" title="字符删除"></a><strong>字符删除</strong></h4><ul>
<li>删除光标前边的字符：ctrl + h（Backspace）</li>
<li>删除光标后边的字符：ctrl + d  （光标后边的字符即光标覆盖的字符）</li>
<li>删除光标前所有内容：ctrl + u</li>
<li>删除光标后所有内容：ctrl + k</li>
</ul>
<h4 id="终端相关快捷键"><a href="#终端相关快捷键" class="headerlink" title="终端相关快捷键"></a><strong>终端相关快捷键</strong></h4><p>(终端必须选中)</p>
<p>Ctrl + Shift + N 新建一个终端 （默认在当前目录重启一个终端）</p>
<p>Ctrl + Shift + T 在终端里新建一个标签</p>
<p>Ctrl + Shift + W 关闭标签页 </p>
<p>Ctrl + Shift + Q 关闭窗口</p>
<p>Ctrl + Shift + C 复制 Ctrl + Shift + V 粘贴</p>
<p>Alt + [1 - 9] 标签之间切换</p>
<p>Ctrl + Shift + &#x3D; 放大终端字体 </p>
<p>Ctrl + - 缩小终端字体 </p>
<p>Ctrl + 0（主键盘区的0） 普通大小 </p>
<p>F11 全屏  再次按F11退出全屏**** </p>
<p>Ctrl + D 关闭当前一个终端 </p>
<p>Alt + F4 关闭整个终端</p>
<p>Alt + Tab 应用程序间切换 </p>
<p>Ctrl + Alt + F7 回到图形界面</p>
<p>Ctrl + Alt + F1到 Ctrl + Alt + F6 可以访问6个虚拟控制台</p>
<h3 id="find（找文件）"><a href="#find（找文件）" class="headerlink" title="find（找文件）"></a><strong>find（找文件）</strong></h3><p>find命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。</p>
<p><strong>按文件名查询：使用参数 -name</strong></p>
<p><strong>命令：find + 路径 + -name +“文件名”</strong></p>
<p>示例：find &#x2F;home -name “a.txt”</p>
<p><strong>按文件大小查询：使用参数 -size</strong></p>
<p>命令：find + 路径 + -size + 范围</p>
<p>范围</p>
<ul>
<li><p>大于：+表示 – +100k</p>
</li>
<li><p>小于：-表示 – -100k</p>
</li>
<li><p>等于: 不需要添加符号 – 100k</p>
</li>
</ul>
<p>  大小</p>
<ul>
<li><p>M 必须大写（10M）</p>
</li>
<li><p>k 必须小写（20k）</p>
</li>
</ul>
<p>例子: 查询目录为家目录</p>
<p>等于100k的文件: find ~&#x2F; -size 100k</p>
<p>大于100k的文件: find ~&#x2F; -size +100k</p>
<p>大于50k, 小于100k的文件: find ~&#x2F; -size +50k -size -100k</p>
<p><strong>按文件类型查询：使用参数 -type</strong></p>
<p>命令：find + 路径 + -type + 类型</p>
<p>类型</p>
<ul>
<li>普通文件类型用 <strong>f</strong> 表示而不是-</li>
<li>d -&gt; 目录fin</li>
<li>l -&gt; 符号链接</li>
<li>b -&gt; 块设备文件</li>
<li>c -&gt; 字符设备文件</li>
<li>s -&gt; socket文件，网络套接字</li>
<li>p -&gt; 管道</li>
</ul>
<h3 id="压缩包管理-重点"><a href="#压缩包管理-重点" class="headerlink" title="压缩包管理(重点)"></a><strong>压缩包管理(重点)</strong></h3><p>tar -cvf 创建归档文件 文件1 文件2  …</p>
<p>tar -xvf 解除归档文件(还原)</p>
<p>tar -tvf 查看归档文件内容</p>
<p><strong>压缩一个目录需要先把目录打包为一个文件，然后再压缩。</strong></p>
<p>例如：<strong>tar -zcvf test.tar.gz 1.c 2.c 3.c 4.c</strong>把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz</p>
<p><strong>解压到指定目录：</strong>-C （大写字母“C”）</p>
<p>例子：tar -xvf new.tar.gz -C .&#x2F;test&#x2F; 将 new.tar.gz 解压到当前目录下的 test 目录下：</p>
<h3 id="内建命令和外部命令"><a href="#内建命令和外部命令" class="headerlink" title="内建命令和外部命令"></a><strong>内建命令和外部命令</strong></h3><p>内建命令要比系统论命令有比较高的执行效率。外部命令执行时往往需要fork出（产生出）一个子进程，而内建命令一般不用。外部命令是在bash之外额外安装的，通常放在&#x2F;bin，&#x2F;usr&#x2F;bin，&#x2F;sbin，&#x2F;usr&#x2F;sbin……等等。<strong>可通过“echo $PATH”命令查看外部命令的存储路径，</strong>比如：ls、vi等。</p>
<ul>
<li><strong>help + 内建命令</strong></li>
<li><strong>外部命令(–help)</strong></li>
</ul>
<h3 id="man手册"><a href="#man手册" class="headerlink" title="man手册"></a>man手册</h3><p><strong>1)．Standard commands（标准命令）</strong></p>
<p><strong>2)．System calls（系统调用，如open,write）</strong></p>
<p><strong>3)．Library functions（库函数，如printf,fopen）</strong></p>
<p>4)．Special devices（设备文件的说明，&#x2F;dev下各种设备）</p>
<p>5)．File formats（文件格式，如passwd）</p>
<p>6)．Games and toys（游戏和娱乐）</p>
<p>7)．Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</p>
<p>8)．Administrative Commands（管理员命令，如ifconfig）</p>
<p>9   内核例程 [非标准</p>
<h3 id="软件安装和卸载"><a href="#软件安装和卸载" class="headerlink" title="软件安装和卸载"></a><strong>软件安装和卸载</strong></h3><h4 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a><strong>在线安装</strong></h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>sudo apt-get update</td>
<td>获得最新的软件包的列表</td>
</tr>
<tr>
<td>sudo apt-get install xxx</td>
<td>从源中安装xxx软件</td>
</tr>
<tr>
<td>sudo apt-get remove xxx</td>
<td>删除xxx软件</td>
</tr>
<tr>
<td>sudo apt-get clean</td>
<td>清理安装包</td>
</tr>
</tbody></table>
<h4 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a><strong>软件包安装</strong></h4><p>在Ubuntu下安装文件为deb格式</p>
<p>软件安装</p>
<p>sudo dpkg -i xxx.deb</p>
<p>软件卸载</p>
<p>sudo dpkg -r 软件名</p>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a><strong>ln</strong></h3><p>链接文件分为软链接和硬链接：</p>
<ul>
<li>软链接：软链接不占用磁盘空间，源文件删除则软链接失效。</li>
<li>硬链接：硬链接只能链接普通文件，不能链接目录。</li>
</ul>
<p>使用格式：</p>
<p>ln 源文件 链接文件</p>
<p>ln -s 源文件 链接文件</p>
<p>如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。</p>
<p>注意：如果软链接文件和源文件不在同一个目录，源文件最好要使用绝对路径，不要使用相对路径。</p>
<h2 id="2-vi编辑器"><a href="#2-vi编辑器" class="headerlink" title="2.vi编辑器"></a>2.vi编辑器</h2><p><img src="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.2it4biftu9a0.webp" alt="avatar"></p>
<p>官方教程:vimtutor</p>
<h4 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h4><p>1.<strong>切换到编辑模式</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>光标位置当前处插入文字</td>
</tr>
<tr>
<td>I</td>
<td>光标所在行首插入文字</td>
</tr>
<tr>
<td>o(字母)</td>
<td>光标下一行插入文字（新行）</td>
</tr>
<tr>
<td>O(字母)</td>
<td>光标上一行插入文字（新行）</td>
</tr>
<tr>
<td>a</td>
<td>光标位置右边插入文字</td>
</tr>
<tr>
<td>A</td>
<td>光标所在行尾插入文字</td>
</tr>
<tr>
<td>s</td>
<td>删除光标后边的字符，从光标当前位置插入</td>
</tr>
<tr>
<td>S</td>
<td>删除光标所在当前行，从行首插入</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>光标移动</strong></li>
</ol>
<table>
<thead>
<tr>
<th><strong>按键</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + f</td>
<td>向前滚动一个屏幕</td>
</tr>
<tr>
<td>Ctrl + b</td>
<td>向后滚动一个屏幕</td>
</tr>
<tr>
<td>gg</td>
<td>到文件第一行行首</td>
</tr>
<tr>
<td>G(大写)</td>
<td>到文件最后一行行首，G必须为大写</td>
</tr>
<tr>
<td>mG或mgg</td>
<td>到指定行，m为目标行数</td>
</tr>
<tr>
<td>0(数字)</td>
<td>光标移到到行首（第一个字符位置）</td>
</tr>
<tr>
<td>$</td>
<td>光标移到到行尾</td>
</tr>
<tr>
<td>l(小写L)</td>
<td>向右移动光标</td>
</tr>
<tr>
<td>h</td>
<td>向左移动光标</td>
</tr>
<tr>
<td>k</td>
<td>向上移动光标</td>
</tr>
<tr>
<td>j</td>
<td>向下移动光标</td>
</tr>
<tr>
<td>^</td>
<td>光标移到到行首（第一个有效字符位置）</td>
</tr>
</tbody></table>
<p>​	3.<strong>复制粘贴</strong></p>
<table>
<thead>
<tr>
<th><strong>按键</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[n]yy</td>
<td>复制从当前行开始的 n 行</td>
</tr>
<tr>
<td>p</td>
<td>把粘贴板上的内容插入到当前行的下一行</td>
</tr>
</tbody></table>
<h2 id="3-静态连接和动态连接"><a href="#3-静态连接和动态连接" class="headerlink" title="3.静态连接和动态连接"></a>3.静态连接和动态连接</h2><h3 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h3><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。</p>
<p>按照习惯,一般以“.a”做为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自己定义即可</li>
<li>后缀：.a</li>
</ul>
<p>所以最终的静态库的名字应该为：<strong>libxxx.a</strong></p>
<p><img src="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.4pcberglbfk0.webp" alt="avatar"></p>
<p><strong>步骤1：将c源文件生成对应的.o文件（二进制文件）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在使用ar工具是时候需要添加参数：rcs</span><br><span class="line">r更新</span><br><span class="line">c创建</span><br><span class="line">s建立索引</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">ar -rcs libtest1.a *.o</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</strong></p>
<p>静态库制作完成之后，需要将.a文件和头文件一起发布给用户。</p>
<p>假设测试文件为main.c，静态库文件为libtest.a头文件为head.h</p>
<p>编译命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -ltest1 -I.</span><br><span class="line">-L：表示要连接的库所在目录</span><br><span class="line">-I./: I(大写i) 表示指定头文件的目录为当前目录</span><br><span class="line">-l(小写L)：指定链接时需要的库，去掉前缀和后缀</span><br></pre></td></tr></table></figure>

<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p>
<p>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p>
<p><img src="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.6suwowfml400.webp" alt="avatar"></p>
<p>按照习惯,一般以“.so”做为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自己定义即可</li>
<li>后缀：.so</li>
</ul>
<p>所以最终的动态库的名字应该为：libxxx.so</p>
<p>步骤一：生成目标文件，此时要加编译选项：-fPIC（fpic）</p>
<p>参数：-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c add.c -o add.o</span><br></pre></td></tr></table></figure>

<p>步骤二：生成共享库，此时要加链接器选项: -shared（指定生成动态链接库）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared *.o -o libmymath.so</span><br><span class="line">也可以合成一步：gcc sub.c mul.c -fPIC -shared -o libmymath.so</span><br><span class="line">编译:gcc test.c -L. -lmymath</span><br></pre></td></tr></table></figure>

<p><strong>如何让系统找到动态库</strong></p>
<ul>
<li>方法一、拷贝自己制作的共享库到&#x2F;lib或者&#x2F;usr&#x2F;lib(不能是&#x2F;lib64目录)（不建议，因为会污染系统库）</li>
<li>方法二：临时设置LD_LIBRARY_PATH：（只对当前终端有效，重启终端后需要重新设置）</li>
</ul>
<p>export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径</p>
<ul>
<li>方法三、永久设置,把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径，设置到~&#x2F;.bashrc或者 &#x2F;etc&#x2F;profile文件中</li>
</ul>
<p>使环境变量生效</p>
<p>source ~&#x2F;.bashrc </p>
<h2 id="4-MakeFile"><a href="#4-MakeFile" class="headerlink" title="4.MakeFile"></a>4.MakeFile</h2><p>测试程序： test.c add.c sub.c mul.c div.c</p>
<h3 id="最简单的Makefile"><a href="#最简单的Makefile" class="headerlink" title="最简单的Makefile"></a>最简单的Makefile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:test.c add.c sub.c mul.c div.c    </span><br><span class="line">    gcc test.c add.c sub.c mul.c div.c -o test</span><br></pre></td></tr></table></figure>

<p>缺点：效率低，修改一个文件，所有文件会被全部编译</p>
<h3 id="第二个版本Makefile"><a href="#第二个版本Makefile" class="headerlink" title="第二个版本Makefile"></a><strong>第二个版本Makefile</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test:test.o add.o sub.o mul.o div.o</span><br><span class="line">    gcc test.o add.o sub.o mul.o div.o -o test</span><br><span class="line">test.o:test.c</span><br><span class="line">    gcc -c test.c</span><br><span class="line">add.o:add.c</span><br><span class="line">    gcc -c add.c</span><br><span class="line">sub.o:sub.c</span><br><span class="line">    gcc -c sub.c</span><br><span class="line">mul.o:mul.c</span><br><span class="line">    gcc -c mul.c</span><br><span class="line">div.o:div.c</span><br><span class="line">    gcc -c div.c</span><br></pre></td></tr></table></figure>

<h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(变量名)或$&#123;变量名&#125;</span><br><span class="line">除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。</span><br><span class="line">CC = gcc <span class="meta">#arm-linux-gcc </span></span><br><span class="line">CPPFLAGS : C预处理的选项 如:-I</span><br><span class="line">CFLAGS: C编译器的选项 -Wall -g -c</span><br><span class="line">LDFLAGS : 链接器选项 -L -l</span><br><span class="line">$@: 表示规则中的目标</span><br><span class="line">$&lt;: 表示规则中的第一个依赖</span><br><span class="line">$^: 表示规则中的所有依赖, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#变量</span><br><span class="line">OBJS=add.o sub.o mul.o div.o test.o add.o</span><br><span class="line">TARGET=test</span><br><span class="line">CC=gcc</span><br><span class="line">#$@: 表示目标</span><br><span class="line">#$&lt;: 表示第一个依赖</span><br><span class="line">#$^: 表示所有的依赖</span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">    #$(CC) $(OBJS) -o $(TARGET) </span><br><span class="line">    $(CC) $^ -o $@</span><br><span class="line">    echo $@</span><br><span class="line">    echo $&lt;</span><br><span class="line">    echo $^  </span><br><span class="line">add.o:add.c</span><br><span class="line">    $(CC) -c $&lt; -o $@ </span><br><span class="line">sub.o:sub.c</span><br><span class="line">    $(CC) -c $&lt; -o $@ </span><br><span class="line">mul.o:mul.c</span><br><span class="line">    $(CC) -c $&lt; -o $@ </span><br><span class="line">div.o:div.c</span><br><span class="line">    $(CC) -c $&lt; -o $@ </span><br><span class="line">test.o:test.c</span><br><span class="line">    $(CC) -c $&lt; -o $@</span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS) $(TARGET)</span><br></pre></td></tr></table></figure>

<h3 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a><strong>模式规则</strong></h3><p>%.o:%.c</p>
<p>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p>
<p>Makefile第三个版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OBJS=test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">    gcc $(OBJS) -o $(TARGET)</span><br><span class="line">%.o:%.c</span><br><span class="line">    gcc -c $&lt; -o $@</span><br></pre></td></tr></table></figure>

<h3 id="Makefile中的函数"><a href="#Makefile中的函数" class="headerlink" title="Makefile中的函数"></a><strong>Makefile中的函数</strong></h3><p>makefile中的函数有很多，在这里给大家介绍三个最常用的。</p>
<p>1、wildcard – 查找指定目录下的指定类型的文件</p>
<p>src &#x3D; $(wildcard *.c) &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件,赋值给src</p>
<p>2、patsubst – 查找替换</p>
<p>obj &#x3D; $(patsubst %.c,%.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
<p>3、notdir -去除路径</p>
<p>obj &#x3D; $(notdir $(src)); &#x2F;&#x2F;去除src中的路径</p>
<p>在makefile中所有的函数都是有返回值的。</p>
<p>Makefile第四个版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SRC=$(wildcard *.c) </span><br><span class="line">OBJS=$(patsubst %.c, %.o, $(SRC))</span><br><span class="line">TARGET=test </span><br><span class="line">$(TARGET):$(OBJS) </span><br><span class="line">   gcc $(OBJS) -o $(TARGET)   </span><br><span class="line">%.o:%.c</span><br><span class="line">   gcc -c $&lt; -o $@</span><br></pre></td></tr></table></figure>

<h3 id="Makefile中的伪目标"><a href="#Makefile中的伪目标" class="headerlink" title="Makefile中的伪目标"></a><strong>Makefile中的伪目标</strong></h3><p><strong>clean用途: 清除编译生成的中间.o文件和最终目标文件</strong></p>
<p>make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令。</p>
<p><strong>伪目标声明:</strong> <strong>.PHONY:clean</strong></p>
<p>声明目标为伪目标之后，makefile将不会再判断目标是否存在或者该目标是否需要更新</p>
<p>Makefile第五个版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SRC=$(wildcard *.c)</span><br><span class="line">OBJS=$(patsubst %.c, %.o, $(SRC))</span><br><span class="line">TARGET=test</span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">    gcc $(OBJS) -o $(TARGET) </span><br><span class="line">%.o:%.c</span><br><span class="line">    gcc -c $&lt; -o $@</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS) $(TARGET)</span><br><span class="line">总结： 一条规则，两个函数，三个变量。</span><br><span class="line">一条规则：</span><br><span class="line">目标：依赖</span><br><span class="line">命令</span><br><span class="line">两个函数：</span><br><span class="line">wildcard patsubst</span><br><span class="line">三个变量：</span><br><span class="line">$@</span><br><span class="line">$&lt;</span><br><span class="line">$^</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a><strong>练习</strong></h3><p>在当前目录（假设叫dir）中有如下目录和文件， 编写Makefile在当前目录的&#x2F;bin下，生成可执行文件test。</p>
<p>├── bin<br>│   └── test<br>├── calc<br>├── inc<br>│   ├── add.h<br>│   ├── div.h<br>│   ├── mul.h<br>│   ├── sub.h<br>│   └── test.h<br>├── Makefile<br>├── obj<br>│   ├── add.o<br>│   ├── div.o<br>│   ├── mul.o<br>│   ├── sub.o<br>│   └── test.o<br>└── src<br>    ├── add.c<br>    ├── div.c<br>    ├── mul.c<br>    ├── sub.c<br>    └── test.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> SOURCE=$(wildcard src<span class="comment">//*.c)  //找到当前目录下所有后缀为.c的文件,赋值给src</span></span><br><span class="line"> objs=$(notdir $(SOURCE))    <span class="comment">//去除src中的路径</span></span><br><span class="line"> OBJS=$(patsubst %.c,obj/%.o,$(objs)) <span class="comment">//把src变量里所有后缀为.c的文件替换成.o</span></span><br><span class="line"> #OBJS=$(patsubst %.c,%.o,$(SOURCE))       </span><br><span class="line"> CPPFLAGS=-I ./inc/     <span class="comment">//CPPFLAGS : C预处理的选项 如:-I</span></span><br><span class="line"> TARGET=bin/test        <span class="comment">//生成目标文件</span></span><br><span class="line"> CC=gcc   </span><br><span class="line">$(TARGET):      $(OBJS)</span><br><span class="line">     $(CC) $(OBJS) -o $(TARGET) $(CPPFLAGS)</span><br><span class="line">obj/%.o: src/%.c</span><br><span class="line">     $(CC) -c $&lt; -o $@ $(CPPFLAGS)</span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">     rm $(OBJS) $(TARGET)</span><br><span class="line">#$@: 表示目标 #$&lt;: 表示第一个依赖 #$^: 表示所有的依赖</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SOURCE = $(wildcard src<span class="comment">//*.c)</span></span><br><span class="line">objs = $(notdir $(SOURCE))</span><br><span class="line">OBJS = $(patsubst %.c,obj/%.o,$(objs))</span><br><span class="line">CC = gcc </span><br><span class="line">CPPFLAGS = -I ./inc</span><br><span class="line">TARGET = calc</span><br><span class="line">calc:   $(OBJS)</span><br><span class="line">        $(CC) $(OBJS) -o $(TARGET)</span><br><span class="line">        #$(CC) $(OBJS) -o $(TARGET) $(CPPFLAGS)</span><br><span class="line">obj/add.o:  src/add.c</span><br><span class="line">        $(CC) -c src/add.c -o obj/add.o </span><br><span class="line">obj/sub.o:  src/sub.c</span><br><span class="line">        $(CC) -c src/sub.c -o obj/sub.o </span><br><span class="line">obj/div.o:  src/div.c</span><br><span class="line">        $(CC) -c src/div.c -o obj/div.o </span><br><span class="line">obj/mul.o:  src/mul.c</span><br><span class="line">        $(CC) -c src/mul.c -o obj/mul.o </span><br><span class="line">obj/test.o: src/test.c</span><br><span class="line">        $(CC) -c src/test.c -o obj/test.o $(CPPFLAGS)</span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>



<h2 id="文件目录操作函数"><a href="#文件目录操作函数" class="headerlink" title="文件目录操作函数"></a>文件目录操作函数</h2><h3 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h3><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                          </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">功能：获取文件状态信息</span><br><span class="line">stat和lstat的区别：</span><br><span class="line">        当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；</span><br><span class="line">        而stat返回的是该链接指向的文件的信息（穿透）。</span><br><span class="line">参数： path：文件名  buf：保存文件信息的结构体</span><br><span class="line">返回值：成功： <span class="number">0</span>  失败: <span class="number">-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>           st_dev;     <span class="comment">//文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span>           st_ino;     <span class="comment">//节点</span></span><br><span class="line">    <span class="type">mode_t</span>          st_mode;    <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">    <span class="type">nlink_t</span>         st_nlink;   <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="type">uid_t</span>           st_uid;     <span class="comment">//用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>           st_gid;     <span class="comment">//组ID</span></span><br><span class="line">    <span class="type">dev_t</span>           st_rdev;    <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="type">off_t</span>           st_size;    <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">    <span class="type">blksize_t</span>       st_blksize; <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="type">blkcnt_t</span>        st_blocks;  <span class="comment">//块数</span></span><br><span class="line">    <span class="type">time_t</span>          st_atime;   <span class="comment">//最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span>          st_mtime;   <span class="comment">//最后一次修改时间</span></span><br><span class="line">    <span class="type">time_t</span>          st_ctime;   <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">stat(<span class="string">&quot;xxx&quot;</span>,&amp;s);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">l</span>;</span></span><br><span class="line">l = localtime(&amp;s.st_ctime);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d年%d月%d日%d时%d分%d秒\n&quot;</span>,l-&gt;tm_year+<span class="number">1900</span>,l-&gt;tm_mon+<span class="number">1</span>,l-&gt;tm_mday,l-&gt;tm_hour,l-&gt;tm_min,l-&gt;tm_sec);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.4k490wpc1je0.webp" alt="avatar"></p>
<p>st_mode(16位整数)参数说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.st_mode &amp; S_IRUSR) <span class="comment">//400</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(s.st_mode &amp; S_IWUSR) <span class="comment">//200 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(s.st_mode &amp; S_IXUSR) <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH == <span class="number">777</span>(<span class="number">8</span>进制)   <span class="number">111</span> <span class="number">101</span> <span class="number">101</span>(<span class="number">2</span>进制 <span class="number">755</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件类型判断使用宏函数：</p>
<table>
<thead>
<tr>
<th align="center">Macro</th>
<th align="center">Type of file</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_ISREG()</td>
<td align="center">regular file</td>
</tr>
<tr>
<td align="center">S_ISDIR()</td>
<td align="center">directory file</td>
</tr>
<tr>
<td align="center">S_ISCHR()</td>
<td align="center">character special file</td>
</tr>
<tr>
<td align="center">S_ISblk()</td>
<td align="center">block special file</td>
</tr>
<tr>
<td align="center">S_ISFIFO()</td>
<td align="center">pipe of FIFO</td>
</tr>
<tr>
<td align="center">S_ISLNK()</td>
<td align="center">symbolic link</td>
</tr>
<tr>
<td align="center">S_ISSOCK()</td>
<td align="center">socket</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (S_ISREG(s.st_mode))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;这是普通文件&quot;</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>首位字母</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td align="left">目录文件directory</td>
</tr>
<tr>
<td>l</td>
<td align="left">符号链接文件link 软链接 快捷方式</td>
</tr>
<tr>
<td>b</td>
<td align="left">块文件block 随机读，随机存的设备 （光驱光盘，硬盘） 表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</td>
</tr>
<tr>
<td>c</td>
<td align="left">字符设备character 顺序存取设备-键盘鼠标 表示为装置文件里面的串行端口设备,例如键盘、鼠标(一次性读取装置)</td>
</tr>
<tr>
<td>s</td>
<td align="left">套接字文件socket ip port</td>
</tr>
<tr>
<td>p</td>
<td align="left">管道文件pipe</td>
</tr>
</tbody></table>
<h4 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件名</span><br><span class="line">    mode：文件权限，<span class="number">4</span>种权限</span><br><span class="line">        R_OK：   是否有读权限</span><br><span class="line">        W_OK：   是否有写权限</span><br><span class="line">        X_OK：   是否有执行权限</span><br><span class="line">        F_OK：   测试文件是否存在</span><br><span class="line">返回值： <span class="number">0</span>：  有某种权限，或者文件存在 <span class="number">-1</span>：没有，或文件不存在</span><br><span class="line">access(<span class="string">&quot;txt&quot;</span>, F_OK);</span><br></pre></td></tr></table></figure>

<h4 id="chmod函数"><a href="#chmod函数" class="headerlink" title="chmod函数"></a>chmod函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：修改文件权限</span><br><span class="line">参数：</span><br><span class="line">    filename：文件名</span><br><span class="line">    mode：权限(<span class="number">8</span>进制数)</span><br><span class="line">返回值：成功：<span class="number">0</span>  失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="chown函数"><a href="#chown函数" class="headerlink" title="chown函数"></a>chown函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line">功能：修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件或目录名</span><br><span class="line">    owner：文件所有者id，通过查看 /etc/passwd 得到所有者id</span><br><span class="line">    group：文件所属组id，通过查看 /etc/group 得到用户组id</span><br><span class="line">返回值：成功：<span class="number">0</span>失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line">功能：修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件或目录名</span><br><span class="line">    owner：文件所有者id，通过查看 /etc/passwd 得到所有者id</span><br><span class="line">    group：文件所属组id，通过查看 /etc/group 得到用户组id</span><br><span class="line">返回值： 成功：<span class="number">0</span>  失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath：源文件名字</span><br><span class="line">    newpath：硬链接名字</span><br><span class="line">返回值： 成功：<span class="number">0</span>失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linkpath：软链接名字</span><br><span class="line">返回值：成功：<span class="number">0</span> 失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="文件描述符复制"><a href="#文件描述符复制" class="headerlink" title="文件描述符复制"></a><strong>文件描述符复制</strong></h3><h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">功能：通过 oldfd 复制出一个新的文件描述符，新的文件描述符是调用进程文件描述符表中最小可用的文件描述符，最终 oldfd 和新的文件描述符都指向同一个文件。</span><br><span class="line">参数：oldfd : 需要复制的文件描述符 oldfd</span><br><span class="line">返回值：成功：新文件描述符 失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="dup函数-1"><a href="#dup函数-1" class="headerlink" title="dup函数"></a>dup函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">功能：通过 oldfd 复制出一个新的文件描述符 newfd，如果成功，newfd 和函数返回值是同一个返回值，最终 oldfd 和新的文件描述符 newfd 都指向同一个文件。</span><br><span class="line">参数：oldfd : 需要复制的文件描述符</span><br><span class="line">     newfd : 新的文件描述符，这个描述符可以人为指定一个合法数字（<span class="number">0</span> - <span class="number">1023</span>），如果指定的数字已经被占用（和某个文件有关联），此函数会自动关闭 close() 断开这个数字和某个文件的关联，再来使用这个合法数字。</span><br><span class="line">返回值：成功：返回 newfd 失败：返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span>)</span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件描述符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数<span class="type">int</span> arg。</span><br><span class="line">返回值：成功：返回某个其他值 失败：<span class="number">-1</span></span><br><span class="line">fcntl函数有<span class="number">5</span>种功能：</span><br><span class="line"><span class="number">1</span>) 复制一个现有的描述符（cmd=F_DUPFD）（现阶段掌握）</span><br><span class="line"><span class="number">2</span>) 获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD)</span><br><span class="line"><span class="number">3</span>) 获得／设置文件状态标记(cmd=F_GETFL或F_SETFL) （这个状态标记是open的时候指定的标记）</span><br><span class="line"><span class="number">4</span>) 获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)</span><br><span class="line"><span class="number">5</span>) 获得／设置记录锁(cmd=F_GETLK, F_SETLK或F_SETLKW)</span><br></pre></td></tr></table></figure>

<h3 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h3><h4 id="getcwd函数"><a href="#getcwd函数" class="headerlink" title="getcwd函数"></a>getcwd函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">功能：获取当前进程的工作目录</span><br><span class="line">参数：</span><br><span class="line">    buf : 缓冲区，存储当前的工作目录</span><br><span class="line">    size : 缓冲区大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：buf中保存当前进程工作目录位置</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="chdir函数"><a href="#chdir函数" class="headerlink" title="chdir函数"></a>chdir函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chdir(const char *path);</span><br><span class="line">功能：修改当前进程(应用程序)的路径</span><br><span class="line">参数：</span><br><span class="line">    path：切换的路径</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name：目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h4><p>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。</p>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>MMU是Memory Management Unit的缩写，中文名是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a>单元，它是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8">中央处理器</a>（CPU）中用来管理<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">虚拟存储器</a>、物理存储器的控制线路，同时也负责<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80">虚拟地址</a>映射为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">物理地址</a>，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p>
<h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a><strong>进程控制块PCB</strong></h4><p>进程运行时，内核为进程每个进程分配一个PCB（进程控制块），维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a><strong>进程的状态</strong></h4><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p>
<p>在三态模型中，进程状态分为三个基本状态，即<strong>运行态，就绪态，阻塞态</strong>。</p>
<p>在五态模型中，进程分为<strong>新建态、终止态，运行态，就绪态，阻塞态</strong>。</p>
<p>stat中的参数意义如下：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>D是Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</td>
</tr>
<tr>
<td>R</td>
<td>正在运行，或在队列中的进程。 R 是Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</td>
</tr>
<tr>
<td>S(大写)</td>
<td>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</td>
</tr>
<tr>
<td>T</td>
<td>调试状态（T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。向一个进程发送 SIGSTOP 信号{使进程暂停（使用SIGCONT让进程重新激活,SIGSTOP不可以捕获)}。，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。）</td>
</tr>
<tr>
<td>Z</td>
<td>僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>进入内存交换（从内核2.6开始无效）</td>
</tr>
<tr>
<td>X</td>
<td>X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。</td>
</tr>
<tr>
<td>&lt;</td>
<td>高优先级</td>
</tr>
<tr>
<td>N</td>
<td>低优先级</td>
</tr>
<tr>
<td>s</td>
<td>包含子进程</td>
</tr>
<tr>
<td>+</td>
<td>位于前台的进程组</td>
</tr>
<tr>
<td>I（大写的i）</td>
<td>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用</td>
</tr>
</tbody></table>
<p><strong>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</strong></p>
<p>ps命令可以查看进程的详细状况，常用选项(选项可以不加“-”)如下：</p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td>-u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
<tr>
<td>-w</td>
<td>显示加宽，以便显示更多的信息</td>
</tr>
<tr>
<td>-r</td>
<td>只显示正在运行的进程</td>
</tr>
</tbody></table>
<p>ps aux ps ef ps -a ps -ajx</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令用来<strong>动态显示</strong>运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。</p>
<p>在top命令执行后，可以按下按键得到对显示的结果进行排序：</p>
<table>
<thead>
<tr>
<th><strong>按键</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>根据内存使用量来排序</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU占有率来排序</td>
</tr>
<tr>
<td>T</td>
<td>根据进程运行时间的长短来排序</td>
</tr>
<tr>
<td>U</td>
<td>可以根据后面输入的用户名来筛选进程</td>
</tr>
<tr>
<td>K</td>
<td>可以根据后面输入的PID来杀死进程。</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>h</td>
<td>获得帮助</td>
</tr>
</tbody></table>
<h3 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a><strong>进程号和相关函数</strong></h3><h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">    获取调用此函数的进程的父进程号（PPID）</span><br><span class="line">     获取进程组号（PGID）<span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    本进程号</span><br></pre></td></tr></table></figure>

<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a><strong>进程的创建</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程中返回 <span class="number">0</span>，父进程中返回子进程 ID。<span class="type">pid_t</span>，为整型。</span><br><span class="line">    失败：返回<span class="number">-1</span>。</span><br><span class="line">    失败的两个主要原因是：</span><br><span class="line">        <span class="number">1</span>）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。</span><br><span class="line">        <span class="number">2</span>）系统内存不足，这时 errno 的值被设置为 ENOMEM。</span><br></pre></td></tr></table></figure>

<p>使用 fork() 函数得到的子进程是父进程的一个复制品，<strong>它从父进程处继承了整个进程的地址空间：包括进程</strong>上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。</p>
<p><strong>区分父子进程</strong></p>
<p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。这样的话，父进程做了什么事情，子进程也做什么事情，如果我们想要父子进程实现不同的功能该怎么办？</p>
<p><strong>这就通过 fork() 的返回值来区分父子进程，根据不同的返回值来确定是父进程还是子进程，从而决定执行不同的任务。</strong></p>
<p>fork() 函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是 0，而父进程的返回值则是新子进程的进程 ID。</p>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a><strong>kill命令</strong></h4><p>命令功能: 发送指定的信号（软中断）到相应进程。</p>
<p><strong>kill 10311</strong>：10311为应用程序所对应的进程号。</p>
<p>查看信号编号: kill -l(字母)  注意，没有32、33信号。</p>
<p><img src="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.6gsojomqb000.webp" alt="avatar"></p>
<h4 id="等待子进程退出函数"><a href="#等待子进程退出函数" class="headerlink" title="等待子进程退出函数"></a>等待子进程退出函数</h4><p><strong>wait函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status : 进程退出时的状态信息。</span><br><span class="line">返回值：成功：已经结束子进程的进程号 失败： <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) WIFEXITED(status)</span><br><span class="line">为非<span class="number">0</span> → 进程正常结束</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">如上宏为真，使用此宏 → 获取进程退出状态 (<span class="built_in">exit</span>的参数)</span><br><span class="line"><span class="number">2</span>) WIFSIGNALED(status)</span><br><span class="line">为非<span class="number">0</span> → 进程异常终止</span><br><span class="line">WTERMSIG(status)</span><br><span class="line">如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</span><br><span class="line"><span class="number">3</span>) WIFSTOPPED(status)</span><br><span class="line">为非<span class="number">0</span> → 进程处于暂停状态</span><br><span class="line">WSTOPSIG(status)</span><br><span class="line">如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。</span><br><span class="line"><span class="number">4</span>) WIFCONTINUED(status)</span><br><span class="line">为真 → 进程暂停后已经继续运行</span><br></pre></td></tr></table></figure>

<p><strong>wairpid函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br><span class="line">功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：pid : 参数 pid 的值有以下几种类型：</span><br><span class="line">     pid &gt; <span class="number">0</span>  等待进程 ID 等于 pid 的子进程。</span><br><span class="line">     pid = <span class="number">-1</span> 等待任一子进程，此时 waitpid 和 wait 作用一样。</span><br><span class="line">     pid = <span class="number">0</span>  等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。</span><br><span class="line">     pid &lt; <span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。</span><br><span class="line">     status : 进程退出时的状态信息。和 wait() 用法一样。</span><br><span class="line">     options : options 提供了一些额外的选项来控制 waitpid()。</span><br><span class="line">            <span class="number">0</span>：同 wait()，阻塞父进程，等待子进程退出。</span><br><span class="line">            WNOHANG：没有任何已经结束的子进程，则立即返回。</span><br><span class="line">            WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）            </span><br><span class="line">返回值：</span><br><span class="line">    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 <span class="number">3</span> 种情况：</span><br><span class="line">        <span class="number">1</span>) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；</span><br><span class="line">        <span class="number">2</span>) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 <span class="number">0</span>；</span><br><span class="line">        <span class="number">3</span>) 如果调用中出错，则返回<span class="number">-1</span>，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；</span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;父进程启动，子进程ID：%d\n&quot;</span>, child_pid);                                       </span><br><span class="line">waitpid(child_pid, &amp;status, WUNTRACED); <span class="comment">// 等待子进程的状态变化</span></span><br><span class="line"><span class="keyword">if</span>(WIFSTOPPED(status)) </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;子进程通过信号%d暂停\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">waitpid(child_pid, &amp;status, <span class="number">0</span>); <span class="comment">// 等待子进程的状态变化</span></span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(status)) </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;子进程退出，退出状态：%d\n&quot;</span>,WTERMSIG(status));</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;子进程%d正常退出!\n&quot;</span>,WEXITSTATUS(status));</span><br></pre></td></tr></table></figure>

<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><p>Linux操作系统支持的主要进程间通信机制：</p>
<p><img src="https://cdn.staticaly.com/gh/auroraoo577/first@main/pic/image.3pvfoqk16yu0.webp" alt="avatar"></p>
<h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>管道也叫无名管道，是UNIX系统IPC(进程间通信)的最古老形式，所有UNIX系统都支持这种通信机制。</p>
<p>管道有如下特点：</p>
<ul>
<li>半双工：数据在同一时刻只能在一个方向上流动。</li>
<li>数据只能从管道的一端写入，从弄一端读出。</li>
<li>写入管道中的数据遵循先进先出的规则(队列规则一样)</li>
<li>管道所传送的数据是五个师的，这要求的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息。</li>
<li>管道不是普通的文件不数据某个文件系统，其只存在内存中，不占用磁盘空间</li>
<li>管道在内存中对应一个缓冲区，不同的系统其大小不一定相同</li>
<li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据</li>
<li>管道没有名字，只能在具有公共祖先的进程之间使用</li>
</ul>
<h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建无名管道。</span><br><span class="line">参数： pipefd : 为 <span class="type">int</span> 型数组的首地址，其存放了管道的文件描述符 pipefd[<span class="number">0</span>]、pipefd[<span class="number">1</span>]。</span><br><span class="line">    当一个管道建立时，它会创建两个文件描述符 fd[<span class="number">0</span>] 和 fd[<span class="number">1</span>]。其中 fd[<span class="number">0</span>] 固定用于读管道，而 fd[<span class="number">1</span>] 固定用于写管道。一般文件 I/O的函数都可以用来操作管道(lseek() 除外)。</span><br><span class="line">返回值：成功：<span class="number">0</span>  失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="管道读写特点"><a href="#管道读写特点" class="headerlink" title="管道读写特点"></a>管道读写特点</h4><p>使用管道需要注意以下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：</p>
<p><strong>读管道：</strong></p>
<p>Ø 管道中有数据，read返回实际读到的字节数。</p>
<p>Ø 管道中无数据：管道写端被全部关闭，read返回0 (相当于读到文件结尾)</p>
<p>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
<p><strong>写管道：</strong></p>
<p>Ø 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程终止)</p>
<p>Ø 管道读端没有全部关闭：管道已满，write阻塞。</p>
<p>管道未满，write将数据写入，并返回实际写入的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取原来的flags</span></span><br><span class="line"><span class="type">int</span> flags = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">// 设置新的flags</span></span><br><span class="line">flags |= O_NONBLOCK;</span><br><span class="line"><span class="comment">// flags = flags | O_NONBLOCK;</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags);</span><br><span class="line">结论： 如果写端没有关闭，读端设置为非阻塞， 如果没有数据，直接返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<h4 id="查看管道缓冲区函数"><a href="#查看管道缓冲区函数" class="headerlink" title="查看管道缓冲区函数"></a>查看管道缓冲区函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    name：</span><br><span class="line">        _PC_PIPE_BUF，查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX，文件名字字节数的上限</span><br><span class="line">返回值：成功：根据name返回的值的意义也不同。失败： <span class="number">-1</span></span><br><span class="line"><span class="type">long</span> size = fpathconf(fd_pipe[<span class="number">1</span>],_PC_PIPE_BUF);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf == %ld\n&quot;</span>,size); <span class="comment">//4096 </span></span><br><span class="line">实际ubuntu linux下缓冲区大小为<span class="number">65536</span> <span class="number">4096</span>*<span class="number">16</span> </span><br></pre></td></tr></table></figure>

<h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h3><p>管道，由于没有名字，只能用于亲缘关系的进程间通信，为了克服这个缺点，提出了命名管道FIFO，也叫有名管道、FIFO文件。共享文件下不能使用管道</p>
<p>命名管道不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。</p>
<p>命名管道(FIFO)和无名管道(pipe)有一些特点是相同的，不一样的地方在于：</p>
<ul>
<li>FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中</li>
<li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中</li>
<li>FIFO有名字，不相关的进程可以通过打开命名管道进行通信。</li>
</ul>
<h4 id="mkfifo函数"><a href="#mkfifo函数" class="headerlink" title="mkfifo函数"></a>mkfifo函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：命名管道的创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname : 普通的路径名，也就是创建后 FIFO 的名字。</span><br><span class="line">    mode : 文件的权限，与打开普通文件的 open() 函数中的 mode 参数相同。(<span class="number">0666</span>)</span><br><span class="line">返回值：成功：<span class="number">0</span>   状态码 失败：如果文件已经存在，则会出错且返回 <span class="number">-1</span>。</span><br></pre></td></tr></table></figure>


    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://auroraoo577.github.io.git">auroraoo577</a>
            <p>原文链接：<a href="https://auroraoo577.github.io.git/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://auroraoo577.github.io.git/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a>
            <p>发表日期：<a href="https://auroraoo577.github.io.git/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">May 24th 2023, 9:05:47 pm</a>
            <p>更新日期：<a href="https://auroraoo577.github.io.git/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">June 10th 2023, 5:50:06 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2023/06/30/C++/" title= "">
                    <div class="nextTitle">[Untitled Post]</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2023/05/07/list/" title= "链表">
                    <div class="prevTitle">链表</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:2817269704@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/auroraoo577" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number"></span> <span class="toc-text">1.Linux基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash%E8%A7%A3%E6%9E%90%E5%99%A8%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.</span> <span class="toc-text">Bash解析器常用快捷键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%BE%93%E5%85%A5%E7%9A%84%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">遍历输入的历史命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E6%A0%87%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">光标相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.</span> <span class="toc-text">字符删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.4.</span> <span class="toc-text">终端相关快捷键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find%EF%BC%88%E6%89%BE%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">find（找文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%AE%A1%E7%90%86-%E9%87%8D%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">压缩包管理(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%E5%92%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">内建命令和外部命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#man%E6%89%8B%E5%86%8C"><span class="toc-number">5.</span> <span class="toc-text">man手册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-number">6.</span> <span class="toc-text">软件安装和卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85"><span class="toc-number">6.1.</span> <span class="toc-text">在线安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85"><span class="toc-number">6.2.</span> <span class="toc-text">软件包安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ln"><span class="toc-number">7.</span> <span class="toc-text">ln</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-vi%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">2.vi编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vim%E6%93%8D%E4%BD%9C"><span class="toc-number">0.1.</span> <span class="toc-text">vim操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-number"></span> <span class="toc-text">3.静态连接和动态连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">静态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.</span> <span class="toc-text">动态连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MakeFile"><span class="toc-number"></span> <span class="toc-text">4.MakeFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Makefile"><span class="toc-number">1.</span> <span class="toc-text">最简单的Makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%89%88%E6%9C%ACMakefile"><span class="toc-number">2.</span> <span class="toc-text">第二个版本Makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">Makefile中的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">模式规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">Makefile中的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-number">6.</span> <span class="toc-text">Makefile中的伪目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">7.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">文件目录操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">文件操作相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stat%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">stat函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#access%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">access函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chmod%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">chmod函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chown%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">chown函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#truncate%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">truncate函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">link函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symlink%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">symlink函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%A4%8D%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">文件描述符复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">dup函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.2.</span> <span class="toc-text">dup函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">目录相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getcwd%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">getcwd函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chdir%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">chdir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#opendir%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">opendir函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">0.1.</span> <span class="toc-text">进程和程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">0.2.</span> <span class="toc-text">并行和并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMU"><span class="toc-number">0.3.</span> <span class="toc-text">MMU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">0.4.</span> <span class="toc-text">进程控制块PCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">0.5.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top"><span class="toc-number">0.6.</span> <span class="toc-text">top</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">进程号和相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">getpid函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">kill命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">等待子进程退出函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="toc-number"></span> <span class="toc-text">进程间通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.</span> <span class="toc-text">无名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">pipe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">管道读写特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">查看管道缓冲区函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.</span> <span class="toc-text">有名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mkfifo%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">mkfifo函数</span></a></li></ol></li></ol>
    </div>
    
    <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=470 height=330 src="//music.163.com/outchain/player?type=0&id=871336973&auto=1&height=430" style="float: middle;"></iframe> -->
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 22
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span><a class="archive-post-title" href= "/2023/04/05/PairZhuGPT-QQRobot/" >PairZhuGPT-QQRobot部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/SortTest/" >Sort Test()</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2023/02/18/bolg_2/" >Three day</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2023/02/18/bolg_1/" >Themes and share</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2023/06/30/C++/" >[Untitled Post]</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/24</span><a class="archive-post-title" href= "/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" >操作系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/25</span><a class="archive-post-title" href= "/2023/03/25/github%E4%BB%93%E5%BA%93%E6%8C%82%E8%BD%BD%E5%9B%BE%E5%BA%8A/" >图床使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/24</span><a class="archive-post-title" href= "/2023/03/24/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/" >VS创建多个项目</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/24</span><a class="archive-post-title" href= "/2023/03/24/gitee%E9%83%A8%E7%BD%B2/" >gitee部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/%E7%AC%94%E8%AE%B0/" >share</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/playlist/" >歌单分享</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/noteday2/" >css-note</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/note-day0/" >基础语法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/note-day1/" >数组基础知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/eclipsekey/" >eclipse快捷键</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/bolg_4/" >Themes and share</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/bolg_3/" >on the fourth day</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2023/02/16/hello-world/" >Hello World！</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2023/05/07/list/" >链表</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2023/03/24/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" >YQ_复习笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2023/02/18/%E6%B7%BB%E5%8A%A0%E6%92%AD%E6%94%BE%E5%99%A8/" >添加播放器</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2023/07/18/QString%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" >[Untitled Post]</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="应用"><span class="iconfont-archer">&#xe606;</span>应用</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
    <div>
</div> 

    <script>
    var siteMeta = {
        root: "/",
        author: "auroraoo577"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>